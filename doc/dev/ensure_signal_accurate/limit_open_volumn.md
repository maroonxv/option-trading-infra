# 双价开仓与每日开仓限额设计文档

## 1. 背景
为了平衡成交成功率与滑点成本，并严格控制策略的每日风险敞口，需要对开仓逻辑进行升级：
- **双价开仓**：在满足条件时，同时以买一价和卖一价各挂单 1 手。
- **额度控制**：设定单合约及全策略的每日开仓手数上限，防止异常行情下的过度交易。

## 2. 详细需求

### 2.1 双价开仓逻辑
- **触发条件**：策略发出开仓信号且通过流动性检测。
- **执行方式**：
  - 订单 A：价格 = `BidPrice1` (买一价)，数量 = 1 手。
  - 订单 B：价格 = `AskPrice1` (卖一价)，数量 = 1 手。
- **合计**：单次触发共开仓 2 手。

### 2.2 限额规则 (Daily Limits)
1. **单合约限额**：针对每个具体的期权合约，每日累计开仓不得超过 **2 手**。
   - 意味着每个合约每天只能执行一次“双价开仓”。
2. **全局限额**：策略下所有品种及合约，每日累计新增开仓不得超过 **50 手**。
3. **重置规则**：以自然日（或交易日）为单位，每日凌晨（或开盘前）清零计数器。

## 3. 技术方案

### 3.1 状态管理与持久化
在 `VolatilityTrade` 应用服务中引入计数器：
- `daily_open_count_map`: `Dict[str, int]`，记录各合约今日开仓数。
- `global_daily_open_count`: `int`，记录全局今日开仓总数。
- `last_trading_date`: `date`，用于检测日期切换。

**持久化**：
- 修改 `dump_state` 和 `load_state` 方法，将上述三个变量包含在 pickle 存档中，确保程序重启后限额逻辑依然连续。

### 3.2 应用层逻辑变更 (`VolatilityTrade`)

#### A. 数据准备 (`_get_option_contracts`)
- 提取 `tick.ask_price_1` 并填充至候选合约 DataFrame，确保开仓时可获取卖一价。

#### B. 开仓流程拆分 (`_check_and_execute_open`)
1. **日期检查**：对比 `datetime.now().date()` 与 `last_trading_date`，若不同则清空所有计数器并更新日期。
2. **全局拦截**：若 `global_daily_open_count + 2 > 50`，则直接放弃本次开仓。
3. **合约拦截**：在选定 `option_contract` 后，检查 `daily_open_count_map.get(vt_symbol, 0) + 2 > 2`。
4. **双单执行**：
   - 构造 `OrderInstruction(price=bid_price, volume=1)`。
   - 构造 `OrderInstruction(price=ask_price, volume=1)`。
   - 调用 `exec_gateway.send_order` 分别发送两笔订单。
5. **更新计数**：开仓成功（发出指令）后，累加全局和单合约计数器。

### 3.3 领域服务逻辑变更 (`PositionSizingService`)
- 修改 `make_open_decision`：
  - 将默认开仓手数改为 **1 手**（作为基准单元）。
  - 外部应用层将根据此基准单元，配合双价逻辑进行实际下单。

## 4. 关键 API 字段

| 字段 | 来源 | 用途 |
| :--- | :--- | :--- |
| `tick.bid_price_1` | 市场网关 | 第一笔订单的限价 |
| `tick.ask_price_1` | 市场网关 | 第二笔订单的限价 |
| `datetime.now().date()` | 系统时间 | 判断每日额度重置 |

## 5. 验收标准
1. **双单验证**：单次信号触发后，成交/委托记录中应出现两笔价格不同、数量均为 1 的订单。
2. **限额验证**：
   - 手动触发多次信号，观察同一个期权合约在达到 2 手后是否停止下单。
   - 模拟极端情况，验证总手数达到 50 后全策略是否停止下单。
3. **重启验证**：手动修改状态文件或重启程序，确认已使用的额度不会被重置。
